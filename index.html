<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta user-scalable="no" name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=no" />
  <title>PDF Viewer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: grid;
      grid-template-columns: auto 1fr;
      height: 100vh;
      background-color: #525252;
    }

    #pdf-viewer-container {
      height: 100vh;
      overflow: auto;
      background-color: #525252;
      display: flex;
      flex: 1;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    #fileListContainer {
      height: 100%;
      background-color: #151515;
      color: #858585;
      overflow-y: auto;
      z-index: 10;
      width: 4.167vw;
      display: flex;
      flex-direction: column;
      padding-top: 0.833vw;
      position: absolute;
      right: 0px;
    }


    .page {
      margin-bottom: 10px;
      display: block;
      transition: transform 0.3s ease;
    }



    .sidebar {
      height: 94vh;
      margin-top: 2vh;
      margin-left: 1.2vw;
      background-color: #151515;
      color: #858585;
      overflow-y: auto;
      z-index: 10;
      width: 4vw;
      display: flex;
      flex-direction: column;
      padding-top: 0.833vw;
      border-radius: 0.5rem;
    }

    .zoom-button {
      margin: 0.417vw auto;
      display: block;
      cursor: pointer;
      font-size: 0.75vw;
      padding: 0.417vw;
      width: 3.333vw;
      background-color: #444;
      border: none;
      color: #adadad;
      border-radius: 0.21vw;
    }

    .zoom-button:hover {
      background-color: #555;
      color: white;
    }

    .zoom-level-button {
      margin-left: 0.417vw auto;
      display: block;
      cursor: pointer;
      font-size: 0.75vw;
      padding: 0;
      width: 4.167vw;
      background-color: #151515;
      border: none;
      color: #adadad;
      border-radius: 0px;
    }

    #zoom-level {
      text-align: center;
      margin: 0.417vw 0;
      color: #ccc;
      font-size: 0.667vw;
    }

    #fileList {
      margin: 20px 0;
      padding: 0;
      list-style: none;
    }

    #fileList li {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }

    #fileList li:hover {
      background-color: #f5f5f5;
    }

    .loading {
      color: white;
      font-size: 1vw;
      margin-top: 1.667vw;
    }
  </style>
</head>

<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <button class="zoom-button" id="zoomIn">+</button>
    <button class="zoom-level-button" id="zoom-level">100%</button>
    <button class="zoom-button" id="zoomOut">-</button>

    <button class="blank-page-button" id="addBlankPageButton">Add Page</button>
    <button class="test-button" id="testButton">Test</button>

    <!-- Authentication Buttons -->
    <button id="signInButton">Sign in with Google</button>
    <button id="signOutButton">Sign Out</button>
    <button id="loadFolderButton">Load Files</button>
  </div>
  <!-- File List Container -->
  <div id="fileListContainer" class="hidden">
    <h2>PDF Files</h2>
    <ul id="fileList"></ul>
  </div>
  <!-- PDF Viewer Container -->
  <div id="pdf-viewer-container">
    <div class="loading">Loading File...</div>
  </div>
  <!-- Load the Google API client library,Google Identity Services library, PDF.js libraru -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js""></script>

  <script>
    // Drive/Google API Configuration
    const CLIENT_ID = '552849071037-oh0ijpvkcjnh9fl0m29gv4p8q23gc2nm.apps.googleusercontent.com'; // Replace with your OAuth client ID
    const API_KEY = 'AIzaSyAJA1VuGbMKhnU7TCvprbI6nuq4yFo4KhY'; // Replace with your API key
    const DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
    const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';

    let tokenClient;
    let gapiInited = false;
    let gisInited = false;

    // Initialize the API client
    function gapiLoaded() {
      gapi.load('client', initializeGapiClient);
    }

    async function initializeGapiClient() {
      await gapi.client.init({
        apiKey: API_KEY,
        discoveryDocs: DISCOVERY_DOCS,
      });
      gapiInited = true;
      maybeEnableButtons();
    }
    // Initialize the Google Identity Services
    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: '', // Will be set later
      });
      gisInited = true;
      maybeEnableButtons();
    }

    function maybeEnableButtons() {
      if (gapiInited && gisInited) {
        document.getElementById('signInButton').disabled = false;
      }
    }
    // Handle authentication and authorization
    document.getElementById('signInButton').addEventListener('click', handleAuthClick);
    document.getElementById('signOutButton').addEventListener('click', handleSignoutClick);
    document.getElementById('loadFolderButton').addEventListener('click', handleFolderLoad);

    function handleAuthClick() {
      tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) {
          throw resp;
        }
        document.getElementById('signInButton').style.display = 'none';
        document.getElementById('signOutButton').style.display = 'inline-block';
        document.getElementById('folderInput').classList.remove('hidden');

        console.log('Signed in successfully');
      };

      if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
      } else {
        tokenClient.requestAccessToken({prompt: ''});
      }
    }

    function handleSignoutClick() {
      const token = gapi.client.getToken();
      if (token !== null) {
        google.accounts.oauth2.revoke(token.access_token);
        gapi.client.setToken('');
        document.getElementById('signInButton').style.display = 'inline-block';
        document.getElementById('signOutButton').style.display = 'none';
        document.getElementById('folderInput').classList.add('hidden');
        document.getElementById('fileListContainer').classList.add('hidden');
        document.getElementById('viewerContainer').classList.add('hidden');
        document.getElementById('fileList').innerHTML = '';
      }
    }

    function handleFolderLoad() {
      const folderId = "1DS1pTCgmshQREuDIqfEKIvqsskiItt_k";
      if (!folderId) {
        alert('Please enter a valid folder ID.');
        return;
      }

      listFilesInFolder(folderId);
    }

    // List PDF files in the specified folder
    async function listFilesInFolder(folderId) {
      try {
        document.getElementById('fileList').innerHTML = '<li class="loading">Loading files...</li>';
        document.getElementById('fileListContainer').classList.remove('hidden');

        const response = await gapi.client.drive.files.list({
          q: `'${folderId}' in parents and mimeType='application/pdf'`,
          fields: 'files(id, name, webContentLink)',
          orderBy: 'name'
        });

        displayFiles(response.result.files);
      } catch (error) {
        document.getElementById('fileList').innerHTML = `<li class="error">Error loading files: ${error.message}</li>`;
        console.error('Error listing files:', error);
      }
    }

    // Display the list of PDF files
    function displayFiles(files) {
      const fileListElement = document.getElementById('fileList');

      if (!files || files.length === 0) {
        fileListElement.innerHTML = '<li>No PDF files found in this folder.</li>';
        return;
      }

      const fileItems = files.map(file => {
        return `<li data-file-id="${file.id}">${file.name}</li>`;
      }).join('');

      fileListElement.innerHTML = fileItems;

      // Add click handlers to each file
      document.querySelectorAll('#fileList li').forEach(item => {
        item.addEventListener('click', () => {
          const fileId = item.getAttribute('data-file-id');
          const fileName = item.innerText;
          downloadPdf(fileId);
        });
      });
    }
    async function downloadPdf(fileId) {
      try {
        // Show loading indicator
        viewerContainer.innerHTML = '<div class="loading">Loading File...</div>';

        // Use fetch with the access token instead of gapi.client.drive.files.get
        const accessToken = gapi.auth.getToken().access_token;
        const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Get the PDF as an ArrayBuffer
        const arrayBuffer = await response.arrayBuffer();

        // Load the PDF directly with the ArrayBuffer
        pdfjsLib.getDocument({data: arrayBuffer}).promise
          .then(function(pdf) {
            pdfDoc = pdf;
            renderAllPages();
          })
          .catch(function(error) {
            console.error("Error loading PDF: ", error);
            viewerContainer.innerHTML = '<div class="loading">Error loading PDF: ' + error.message + '</div>';
          });
      } catch (error) {
        console.error('Error downloading file:', error);
        viewerContainer.innerHTML = '<div class="loading">Error loading PDF: ' + error.message + '</div>';
      }
    }
    


    // Blank Page Functionality
    function addBlankPage() {
      // If no PDF is loaded, create a new blank canvas
      if (renderedPages.length === 0) {
        createBlankDocument();
        console.log("Created new blank document");
        return;
      }

      // If PDF is loaded, add a blank page
      addBlankCanvas();
    }
    function createBlankDocument() {
      // Clear viewer container
      viewerContainer.innerHTML = '';
      renderedPages = [];

      // Create a blank canvas
      addBlankCanvas();
    }
    
    function addBlankCanvas() {
      // Create a canvas for the blank page
      const A4_WIDTH = 595;
      const A4_HEIGHT = 842;

      // Create container div to hold both canvas layers
      const container = document.createElement("div");
      container.classList.add("canvas-container", "page");
      container.style.position = "relative";
      container.style.width = `${A4_WIDTH * zoom}px`;
      container.style.height = `${A4_HEIGHT * zoom}px`;

      // Create base canvas (background)
      const baseCanvas = document.createElement("canvas");
      baseCanvas.classList.add("blank-page", "base-layer");
      baseCanvas.width = A4_WIDTH;
      baseCanvas.height = A4_HEIGHT;
      baseCanvas.style.position = "absolute";
      baseCanvas.style.top = "0";
      baseCanvas.style.left = "0";
      baseCanvas.style.width = "100%";
      baseCanvas.style.height = "100%";
      baseCanvas.style.overflow = "scroll";

      // Get 2D context and fill with white for base canvas
      const baseContext = baseCanvas.getContext("2d");
      baseContext.fillStyle = "white";
      baseContext.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

      // Create annotation canvas (overlay)
      const annotationCanvas = document.createElement("canvas");
      annotationCanvas.classList.add("annotation-layer");
      annotationCanvas.width = A4_WIDTH;
      annotationCanvas.height = A4_HEIGHT;
      annotationCanvas.style.position = "absolute";
      annotationCanvas.style.top = "0";
      annotationCanvas.style.left = "0";
      annotationCanvas.style.width = "100%";
      annotationCanvas.style.height = "100%";
      annotationCanvas.style.zIndex = "1"; // Ensure annotation layer is on top

      // Set up drawing functionality for annotation layer
      setupAnnotationDrawing(annotationCanvas);

      // Append both canvas elements to container
      container.appendChild(baseCanvas);
      container.appendChild(annotationCanvas);

      // Append the blank page container to the viewer
      viewerContainer.appendChild(container);
      console.log("Blank page with annotation layer added");

      // Add to renderedPages array - use the container as the element
      renderedPages.push({pageNum: renderedPages.length + 1, canvas: container});

      // Update zoom to apply current zoom settings
      updateZoom(0);

      return container;
    }

    // Set up drawing functionality for annotation layer
    function setupAnnotationDrawing(canvas) {
      const ctx = canvas.getContext("2d");
      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;

      // Default drawing settings
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";

      // Mouse events for drawing
      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);

      // Touch events for mobile devices
      canvas.addEventListener("touchstart", handleTouchStart);
      canvas.addEventListener("touchmove", handleTouchMove);
      canvas.addEventListener("touchend", stopDrawing);

      function startDrawing(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        lastX = (e.clientX - rect.left) * scaleX;
        lastY = (e.clientY - rect.top) * scaleY;
      }

      function draw(e) {
        if (!isDrawing) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const currentX = (e.clientX - rect.left) * scaleX;
        const currentY = (e.clientY - rect.top) * scaleY;

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();

        lastX = currentX;
        lastY = currentY;
      }

      function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousedown", {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        startDrawing(mouseEvent);
      }

      function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousemove", {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        draw(mouseEvent);
      }

      function stopDrawing() {
        isDrawing = false;
      }
    }

    // Helper function to clear annotations
    function clearAnnotations() {
      const annotationCanvas = document.querySelector(".annotation-layer");
      if (annotationCanvas) {
        const ctx = annotationCanvas.getContext("2d");
        ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
      }
    }

    // Helper function to change annotation drawing color
    function setAnnotationColor(color) {
      const annotationCanvas = document.querySelector(".annotation-layer");
      if (annotationCanvas) {
        const ctx = annotationCanvas.getContext("2d");
        ctx.strokeStyle = color;
      }
    }

    // Helper function to change annotation line width
    function setAnnotationLineWidth(width) {
      const annotationCanvas = doecument.querySelector(".annotation-layer");
      if (annotationCanvas) {
        const ctx = annotationCanvas.getContext("2d");
        ctx.lineWidth = width;
      }
    }


    
    
  

    // PDF Viewer

    const viewerContainer = document.getElementById("pdf-viewer-container");
    const zoomInButton = document.getElementById("zoomIn");
    const zoomOutButton = document.getElementById("zoomOut");
    const zoomLevelDisplay = document.getElementById("zoom-level");
    let pdfDoc = null;
    let zoom = 1; // Default zoom level
    let renderedPages = [];

    // Load PDF
    function loadPdf(data) {
      pdfjsLib.getDocument({
        data: data,
        // Add these options for more forgiving parsing
        cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/cmaps/',
        cMapPacked: true,
        disableRange: true,
        disableStream: true,
        disableAutoFetch: true,
        isEvalSupported: false
      }).promise
        .then(function(pdf) {
          pdfDoc = pdf;
          renderAllPages();
        })
        .catch(function(error) {
          console.error("Error loading PDF: ", error);
          viewerContainer.innerHTML = '<div class="loading">Error loading PDF: ' + error.message + '</div>';
        });
    }

    // render all pages
    function renderAllPages() {
      viewerContainer.innerHTML = ""; // clear all viewer containers
      renderedPages = [];

      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        renderPage(pageNum); // 1by1 render each page
      }
    }

    //render a single page
    function renderPage(pageNum) {
      pdfDoc.getPage(pageNum).then(function (page) {
        const viewport = page.getViewport({scale: zoom}); // apply zoom scale
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.classList.add("page");
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };

        page
          .render(renderContext)
          .promise.then(function () {
            // Append the rendered page to the viewer container
            viewerContainer.appendChild(canvas);
            renderedPages.push({pageNum, canvas}); // Save the rendered page and canvas
          })
          .catch(function (error) {
            console.error("Error rendering page " + pageNum + ": " + error);
          });
      });
    }
    function setZoom(n) {
      zoom = n;
      updateZoom(0);
    }
    
    // updat zoom
    function updateZoom(factor) {
      zoom += factor; // update zoom
      renderedPages.forEach(({canvas}, index) => {

        zoomLevelDisplay.textContent = `${Math.round(zoom * 100)}%`;


        const scale = zoom;

        // apply scale transform to the canvas WITH smooth transition
        canvas.style.transition =
          "width 0.2s ease, height 0.2s ease, margin 0.2s ease"; // smooth transition for transform & marginTop
        //canvas.style.transform = `scale(${scale})`; // apply the scale transform

        // adjust the canvas width and height based on the zoom factor
        const originalMarginTop = canvas.style.marginTop;
        const originalWidth = canvas.width;
        const originalHeight = canvas.height;

        // adjust the canvas size based on the zoom factor
        canvas.style.width = `${originalWidth * scale}px`;
        canvas.style.height = `${originalHeight * scale}px`;

        // adjust the spacing between pages THE BIG ONE !!!!!!!!
        canvas.style.marginTop = `${scale * 10}px`;
      });
    }

    // Zoom In - Function triggered when Zoom In button is clicked
    zoomInButton.addEventListener("click", () => {
      console.log("Zoom In clicked");
      updateZoom(0.05); // Zoom in by 10%
    });

    // Event listeners
    zoomInButton.addEventListener("click", () => updateZoom(0.1));
    zoomOutButton.addEventListener("click", () => updateZoom(-0.1));
    zoomLevelDisplay.addEventListener("click", () => setZoom(1));
    addBlankPageButton.addEventListener("click",() => addBlankPage());
    testButton.addEventListener("click",() => loadPdf("https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf"));

    // Keyboard shortcuts
    document.addEventListener("keydown", function (event) {
      if (event.ctrlKey) {
        if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          updateZoom(0.1);
        } else if (event.key === "-") {
          event.preventDefault();
          updateZoom(-0.1);
        } else if (event.key === "0") {
          event.preventDefault();
          zoom = 1;
          updateZoom(0);
        }
      }
    });
  </script>
  <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
  <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>

</html>
