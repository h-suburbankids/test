<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <!-- icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"> <!-- LaTeX (Lay-Tek) -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script> <!-- LaTeX (Lay-Tek) -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script> <!-- Math Rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script> <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> <!-- PDF.js Export-->
  <meta charset="UTF-8" />
  <meta user-scalable="no" name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=no" />
  <title>PDF Viewer with Annotations</title>
  <style>
    :root {
      --title-bar-height: 40px;
      --title-bar-color: #1a1a1a;
      --pane-border-radius: 8px;
      --pane-content-background-color: #151515;
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: block;
      grid-template-columns: auto 1fr;
      min-height: 100vh; /* Use min-height to allow expansion */
      background-color: #525252;
      overflow-y: auto; /* Allow vertical scrolling of the whole document */
      overflow-x: hidden;
    }

    #pdf-viewer-container {
      overflow-y: auto;
      background-color: #525252;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      box-sizing: border-box;
      margin-left: calc(4vw + 1.2vw + 20px); /* Account for sidebar width + margin + some padding */
      width: calc(100% - (4vw + 1.2vw + 20px) - 250px); /* Subtract sidebar and fileListContainer widths */
      min-height: 100vh;
    }

    #fileListContainer {
      height: 100%;
      background-color: #151515;
      color: #858585;
      overflow-y: auto;
      z-index: 10;
      width: 250px;
      display: flex;
      flex-direction: column;
      padding-top: 0.833vw;
      position: absolute;
      right: 0px;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    #fileListContainer.visible {
      transform: translateX(0);
    }

    #selectionOverlay {
        position: absolute;
        border: 2px dashed lightseagreen/*blue*/;
        background-color: rgb(32, 178, 170, 0.1) /*rgba(0, 0, 255, 0.1)*/;
        cursor: crosshair;
        display: none;
    }

    .page {
      margin-bottom: 10px;
      display: block;
      transition: transform 0.3s ease;
    }

    .canvas-container {
      margin-bottom: 1.042vw;
      box-shadow: 0 0.104vw 0.26vw rgba(0,0,0,0.3);
      position: relative;
      display: block;
    }

    .sidebar {
      position: fixed;
      height: 94vh;
      margin-top: 2vh;
      margin-left: 1vw;
      background-color: #151515;
      color: #858585;
      overflow-y: auto;
      z-index: 10;
      width: 5vw;
      display: flex;
      flex-direction: column;
      padding-top: 0.833vw;
      border-radius: 0.417vw
    }

    .button {
      margin: 0.417vw auto;
      display: block;
      cursor: pointer;
      font-size: 0.75vw;
      padding: 0.417vw;
      width: 3.333vw;
      background-color: #444;
      border: none;
      color: #adadad;
      border-radius: 0.21vw;
      text-align: center;
    }

    

    .zoom-level-button {
      margin: 0.417vw auto;
      display: block;
      cursor: pointer;
      font-size: 0.75vw;
      padding: 0;
      width: 3.333vw;
      background-color: #151515;
      border: none;
      color: #adadad;
      border-radius: 0px;
      text-align: center;
    }

    #zoom-level {
      text-align: center;
      margin: 0.417vw 0;
      color: #ccc;
      font-size: 0.667vw;
    }

    #fileList {
      margin: 1.042vw 0;
      padding: 0;
      list-style: none;
    }

    #fileList li {
      padding: 0.521vw;
      border-bottom: 0.052vw solid #333;
      cursor: pointer;
    }

    #fileList li:hover {
      background-color: #2a2a2a;
      color: #fff;
    }

    .loading {
      color: white;
      font-size: 1vw;
      margin-top: 1.667vw;
    }

    .hidden {
      display: none;
    }

    .color-picker {
      margin: 0.417vw auto;
      display: block;
      width: 3.333vw;
      height: 1.5vw;
      border: none;
      cursor: pointer;
    }

    .toolbar-divider {
      height: 0.052vw;
      background-color: #333;
      margin: 0.521vw auto;
      width: 80%;
    }

    #penSize {
      margin: 0.417vw auto;
      display: block;
      width: 3.333vw;
    }
    
    

    .pane {
      position: fixed;
      width: 400px;
      height: 750px;
      border-radius: var(--pane-border-radius);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      top: 50px;
      right: 50px;
      z-index: 1;
    }
    .pane ::-webkit-scrollbar {
      width: 10px;
    }
    .pane ::-webkit-scrollbar-thumb {
      background: #1e3a39;
      border-radius: 5px;
    }
    .is-dragging {
      opacity: 0.9;
    }

    .pane .title {
      height: var(--title-bar-height);
      background-color: var(--title-bar-color);
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      border-top-left-radius: var(--pane-border-radius);
      border-top-right-radius: var(--pane-border-radius);
    }

    .pane h2 {
      font-size: 1rem;
      font-weight: bold;
      color: lightseagreen;
      margin: 0;
    }

    .pane .content {
      position: relative;
      background-color: var(--pane-content-background-color);
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .pane .corner {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      cursor: nwse-resize;
      border-top-left-radius: 8px;
      z-index: 10;
    }

    .message-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: auto;
      padding: 1em;
      display: flex;
      flex-direction: column;
    }

    .input-area {
      padding: 12px;
      background-color: var(--pane-content-background-color);
      display: flex;
      gap: 8px;
      border-top: 1px solid #333;
    }

    #userInput {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      background-color: #333;
      color: #d2d2d2;
    }

    button {
      padding: 8px 12px;
      background-color: #2a2a2a;
      color: #d2d2d2;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #3a3a3a;
    }

    .user {
      color: #d2d2d2;
      text-align: left;
      margin-bottom: 12px;
      padding: 8px;
      background-color: #252525;
      border-radius: 6px;
      align-self: flex-start;
      max-width: 80%;
    }

    .bot {
      color: lightseagreen;
      margin-bottom: 12px;
      padding: 8px;
      background-color: #1e3a39;
      border-radius: 6px;
      align-self: flex-start;
      max-width: 80%;
    }

    img {
      max-width: 100%;
      border-radius: 4px;
      margin-top: 8px;
    }
  </style>
</head>

<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <!-- Zoom Controls -->
    <button class="button" id="zoomIn">+</button>
    <button class="zoom-level-button" id="zoom-level">100%</button>
    <button class="button" id="zoomOut">-</button>
    
    <div class="toolbar-divider"></div>
    
    <!-- Drawing Controls -->
    <button class="button" id="drawToggle">Draw</button>
    <input type="color" id="colorPicker" class="color-picker" value="#000000">
    <input type="range" id="penSize" min="1" max="10" value="2">
    <button class="button" id="clearAnnotations">Clear</button>
    
    <div class="toolbar-divider"></div>
    
    <!-- Page Controls -->
    <button class="button" id="addBlankPageButton">Add Page</button>
    <button class="button" id="exportPdfButton">Export PDF</button>
    <button class="button" id="toggleFiles">Files</button>
    
    <div class="toolbar-divider"></div>
    
    <!-- Google Drive Controls -->
    <button class="button" id="signInButton">Sign In</button>
    <button class="button" id="signOutButton" style="display: none;">Sign Out</button>
    <button class="button" id="loadFolderButton">Load Files</button>

    <button class="button" onclick="location.href='subjects.html'">Subjects</button>
  </div>
  
  <!-- File List Container -->
  <div id="fileListContainer">
    <h2>PDF Files</h2>
    <ul id="fileList"></ul>
  </div>
  
  <!-- PDF Viewer Container -->
  <div id="pdf-viewer-container">
    <div class="loading">No file loaded. Click "Add Page" for a blank canvas or load a PDF.</div>
  </div>
  
  <!-- Load the Google API client library, Google Identity Services library, PDF.js library -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

  <script>
    // Drive/Google API Configuration
    const CLIENT_ID = '552849071037-oh0ijpvkcjnh9fl0m29gv4p8q23gc2nm.apps.googleusercontent.com';
    const API_KEY = 'AIzaSyAJA1VuGbMKhnU7TCvprbI6nuq4yFo4KhY';
    const DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
    const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';

    // PDF.js initialization
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // Main variables
    let tokenClient;
    let gapiInited = false;
    let gisInited = false;
    let pdfDoc = null;
    let zoom = 1;
    let renderedPages = [];
    let isDrawingMode = false;

    // DOM elements
    const viewerContainer = document.getElementById("pdf-viewer-container");
    const zoomInButton = document.getElementById("zoomIn");
    const zoomOutButton = document.getElementById("zoomOut");
    const zoomLevelDisplay = document.getElementById("zoom-level");
    const addBlankPageButton = document.getElementById("addBlankPageButton");
    const toggleFilesButton = document.getElementById("toggleFiles");
    const fileListContainer = document.getElementById("fileListContainer");
    const drawToggleButton = document.getElementById("drawToggle");
    const colorPicker = document.getElementById("colorPicker");
    const penSizeSlider = document.getElementById("penSize");
    const clearAnnotationsButton = document.getElementById("clearAnnotations");

    // ===== GOOGLE DRIVE API FUNCTIONS =====
    
    function gapiLoaded() {
      gapi.load('client', initializeGapiClient);
    }

    async function initializeGapiClient() {
      await gapi.client.init({
        apiKey: API_KEY,
        discoveryDocs: DISCOVERY_DOCS,
      });
      gapiInited = true;
      maybeEnableButtons();
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: '', // Will be set later
      });
      gisInited = true;
      maybeEnableButtons();
    }

    function maybeEnableButtons() {
      if (gapiInited && gisInited) {
        document.getElementById('signInButton').disabled = false;
      }
    }

    function handleAuthClick() {
      tokenClient.callback = async (resp) => {
        if (resp.error !== undefined) {
          throw resp;
        }
        document.getElementById('signInButton').style.display = 'none';
        document.getElementById('signOutButton').style.display = 'block';
        console.log('Signed in successfully');
      };

      if (gapi.client.getToken() === null) {
        tokenClient.requestAccessToken({prompt: 'consent'});
      } else {
        tokenClient.requestAccessToken({prompt: ''});
      }
    }

    function handleSignoutClick() {
      const token = gapi.client.getToken();
      if (token !== null) {
        google.accounts.oauth2.revoke(token.access_token);
        gapi.client.setToken('');
        document.getElementById('signInButton').style.display = 'block';
        document.getElementById('signOutButton').style.display = 'none';
        document.getElementById('fileList').innerHTML = '';
        fileListContainer.classList.remove('visible');
      }
    }

    function handleFolderLoad() {
      const folderId = "1DS1pTCgmshQREuDIqfEKIvqsskiItt_k"; // FOLDER ID FOR CLOUD/DRIVE STORAGE
      if (!folderId) {
        alert('No folder ID available.');
        return;
      }

      listFilesInFolder(folderId);
      fileListContainer.classList.add('visible');
    }

    async function listFilesInFolder(folderId) {
      try {
        document.getElementById('fileList').innerHTML = '<li class="loading">Loading files...</li>';

        const response = await gapi.client.drive.files.list({
          q: `'${folderId}' in parents and mimeType='application/pdf'`,
          fields: 'files(id, name, webContentLink)',
          orderBy: 'name'
        });

        displayFiles(response.result.files);
      } catch (error) {
        document.getElementById('fileList').innerHTML = `<li class="error">Error loading files: ${error.message}</li>`;
        console.error('Error listing files:', error);
      }
    }

    function displayFiles(files) {
      const fileListElement = document.getElementById('fileList');

      if (!files || files.length === 0) {
        fileListElement.innerHTML = '<li>No PDF files found in this folder.</li>';
        return;
      }

      const fileItems = files.map(file => {
        return `<li data-file-id="${file.id}">${file.name}</li>`;
      }).join('');

      fileListElement.innerHTML = fileItems;

      // Add click handlers to each file (dont mess this up!)
      document.querySelectorAll('#fileList li').forEach(item => {
        item.addEventListener('click', () => {
          const fileId = item.getAttribute('data-file-id');
          downloadPdf(fileId);
        });
      });
    }

    async function downloadPdf(fileId) {
      try {
        // Loading indicator
        viewerContainer.innerHTML = '<div class="loading">Loading File...</div>';

        // Use fetch WITH the access token
        const accessToken = gapi.auth.getToken().access_token;
        const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Get the PDF as an ArrayBuffer
        const arrayBuffer = await response.arrayBuffer();

        // Load the PDF with the ArrayBuffer
        loadPdf(arrayBuffer);
      } catch (error) {
        console.error('Error downloading file:', error);
        viewerContainer.innerHTML = '<div class="loading">Error loading PDF: ' + error.message + '</div>';
      }
    }

    // ===== PDF VIEWER FUNCTIONS =====

    function loadPdf(data) {
      pdfjsLib.getDocument({
        data: data,
        cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/cmaps/',
        cMapPacked: true,
        disableRange: true,
        disableStream: true,
        disableAutoFetch: true,
        isEvalSupported: false
      }).promise
        .then(function(pdf) {
          pdfDoc = pdf;
          renderAllPages();
        })
        .catch(function(error) {
          console.error("Error loading PDF: ", error);
          viewerContainer.innerHTML = '<div class="loading">Error loading PDF: ' + error.message + '</div>';
        });
    }

    function renderAllPages() {
      viewerContainer.innerHTML = ""; // Clear all viewer containers
      renderedPages = [];

      const renderNextPage = (pageNum) => {
        if (pageNum <= pdfDoc.numPages) {
          renderPage(pageNum);
          // Add small delay between page renders to prevent UI freezing <33
          setTimeout(() => renderNextPage(pageNum + 1), 50);
        }
      };

      renderNextPage(1);
    }

    function renderPage(pageNum) {
      pdfDoc.getPage(pageNum).then(function(page) {
        const viewport = page.getViewport({scale: 1.0}); // Use base scale for rendering (fixed scaling errors)
        
        // DIV Container to hold canvas layers
        const container = document.createElement("div");
        container.classList.add("canvas-container", "page");
        container.style.position = "relative";
        container.style.width = `${viewport.width * zoom}px`;
        container.style.height = `${viewport.height * zoom}px`;
        
        // Base Canvas
        const baseCanvas = document.createElement("canvas");
        baseCanvas.classList.add("pdf-page", "base-layer");
        baseCanvas.width = viewport.width;
        baseCanvas.height = viewport.height;
        baseCanvas.style.position = "absolute";
        baseCanvas.style.top = "0";
        baseCanvas.style.left = "0";
        baseCanvas.style.width = "100%";
        baseCanvas.style.height = "100%";
        
        const context = baseCanvas.getContext("2d");
        
        // Annotation Canvas
        const annotationCanvas = document.createElement("canvas");
        annotationCanvas.classList.add("annotation-layer");
        annotationCanvas.width = viewport.width;
        annotationCanvas.height = viewport.height;
        annotationCanvas.style.position = "absolute";
        annotationCanvas.style.top = "0";
        annotationCanvas.style.left = "0";
        annotationCanvas.style.width = "100%";
        annotationCanvas.style.height = "100%";
        annotationCanvas.style.zIndex = "1"; // Annotation layer on top
        
        // Render PDF on base canvas
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };
        
        page.render(renderContext).promise.then(function() {
          // Setup drawing on annotation layer (each)
          setupAnnotationDrawing(annotationCanvas);
          
          // Append both canvases to container
          container.appendChild(baseCanvas);
          container.appendChild(annotationCanvas);
          
          // Append to viewer
          viewerContainer.appendChild(container);
          
          // Save reference
          renderedPages.push({pageNum, container});
        }).catch(function(error) {
          console.error("Error rendering page " + pageNum + ": " + error);
        });
      });
    }

    // ===== ADD NEW PAGE/CREATE NEW PAGE =====

    function addBlankPage() {
      addBlankCanvas();
    }

    function addBlankCanvas() {
      // Create a canvas for the blank page (A4 dimensions)
      const A4_WIDTH = 595;
      const A4_HEIGHT = 842;

      // Create container div to hold both canvas layers
      const container = document.createElement("div");
      container.classList.add("canvas-container", "page");
      container.style.position = "relative";
      container.style.width = `${A4_WIDTH * zoom}px`;
      container.style.height = `${A4_HEIGHT * zoom}px`;

      // Create base canvas (background)
      const baseCanvas = document.createElement("canvas");
      baseCanvas.classList.add("blank-page", "base-layer");
      baseCanvas.width = A4_WIDTH;
      baseCanvas.height = A4_HEIGHT;
      baseCanvas.style.position = "absolute";
      baseCanvas.style.top = "0";
      baseCanvas.style.left = "0";
      baseCanvas.style.width = "100%";
      baseCanvas.style.height = "100%";

      // Get 2D context and fill with white for base canvas
      const baseContext = baseCanvas.getContext("2d");
      baseContext.fillStyle = "white";
      baseContext.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

      // Create annotation canvas (overlay)
      const annotationCanvas = document.createElement("canvas");
      annotationCanvas.classList.add("annotation-layer");
      annotationCanvas.width = A4_WIDTH;
      annotationCanvas.height = A4_HEIGHT;
      annotationCanvas.style.position = "absolute";
      annotationCanvas.style.top = "0";
      annotationCanvas.style.left = "0";
      annotationCanvas.style.width = "100%";
      annotationCanvas.style.height = "100%";
      annotationCanvas.style.zIndex = "1"; // Ensure annotation layer is on top

      // Set up drawing functionality for annotation layer
      setupAnnotationDrawing(annotationCanvas);

      // Append both canvas elements to container
      container.appendChild(baseCanvas);
      container.appendChild(annotationCanvas);

      // If this is the first page, clear the "No file loaded" message
      if (renderedPages.length === 0) {
        viewerContainer.innerHTML = "";
      }

      // Append the blank page container to the viewer
      viewerContainer.appendChild(container);
      console.log("Blank page with annotation layer added");

      // Add to renderedPages array
      renderedPages.push({pageNum: renderedPages.length + 1, container});

      return container;
    }

    // ===== ANNOTATION FUNCTIONS =====

    function setupAnnotationDrawing(canvas) {
      const ctx = canvas.getContext("2d");
      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;

      // Default drawing settings
      updateDrawingContext(ctx);

      // Mouse events for drawing
      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);

      // Touch events for mobile devices
      canvas.addEventListener("touchstart", handleTouchStart);
      canvas.addEventListener("touchmove", handleTouchMove);
      canvas.addEventListener("touchend", stopDrawing);

      function startDrawing(e) {
        if (!isDrawingMode) return;
        
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        lastX = (e.clientX - rect.left) * scaleX;
        lastY = (e.clientY - rect.top) * scaleY;
      }

      function draw(e) {
        if (!isDrawing || !isDrawingMode) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const currentX = (e.clientX - rect.left) * scaleX;
        const currentY = (e.clientY - rect.top) * scaleY;

        // Update context settings before drawing (in case they changed)
        updateDrawingContext(ctx);
        
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();

        lastX = currentX;
        lastY = currentY;
      }

      function handleTouchStart(e) {
        if (!isDrawingMode) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousedown", {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        startDrawing(mouseEvent);
      }

      function handleTouchMove(e) {
        if (!isDrawingMode) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousemove", {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        draw(mouseEvent);
      }

      function stopDrawing() {
        isDrawing = false;
      }
    }

    function updateDrawingContext(ctx) {
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = penSizeSlider.value;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
    }

    function clearAllAnnotations() {
      document.querySelectorAll(".annotation-layer").forEach(canvas => {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });
    }

    // ===== ZOOM FUNCTIONS =====

    function updateZoom(factor) {
      zoom += factor;
      zoom = Math.max(0.1, Math.min(3, zoom)); // Limit zoom between 0.1 and 3
      
      zoomLevelDisplay.textContent = `${Math.round(zoom * 100)}%`;

      renderedPages.forEach(({container}) => {
        // Get the base canvas within the container
        const baseCanvas = container.querySelector(".base-layer");
        const annotationCanvas = container.querySelector(".annotation-layer");
        
        if (baseCanvas && annotationCanvas) {
          // Get original dimensions
          const originalWidth = baseCanvas.width;
          const originalHeight = baseCanvas.height;
          
          // Apply smooth transition and scale
          container.style.transition = "width 0.2s ease, height 0.2s ease";
          container.style.width = `${originalWidth * zoom}px`;
          container.style.height = `${originalHeight * zoom}px`;
          
          // Add spacing between pages
          container.style.marginBottom = `${20}px`;
        }
      });
    }

    function setZoom(newZoom) {
      zoom = newZoom;
      updateZoom(0);
    }

    // ===== EVENT LISTENERS =====

    // Zoom controls
    zoomInButton.addEventListener("click", () => updateZoom(0.1));
    zoomOutButton.addEventListener("click", () => updateZoom(-0.1));
    zoomLevelDisplay.addEventListener("click", () => setZoom(1));

    // Page controls
    addBlankPageButton.addEventListener("click", addBlankPage);
    toggleFilesButton.addEventListener("click", () => {
      fileListContainer.classList.toggle('visible');
    });
    document.getElementById('exportPdfButton').addEventListener('click', exportPdfWithAnnotations);

    // Drawing controls
    drawToggleButton.addEventListener("click", () => {
      isDrawingMode = !isDrawingMode;
      drawToggleButton.textContent = isDrawingMode ? "Stop Draw" : "Draw";
      drawToggleButton.style.backgroundColor = isDrawingMode ? "#007bff" : "#444";
      document.body.style.cursor = isDrawingMode ? "crosshair" : "default";
    });
    
    clearAnnotationsButton.addEventListener("click", clearAllAnnotations);

    // Google Drive authentication
    document.getElementById('signInButton').addEventListener('click', handleAuthClick);
    document.getElementById('signOutButton').addEventListener('click', handleSignoutClick);
    document.getElementById('loadFolderButton').addEventListener('click', handleFolderLoad);

    // Keyboard shortcuts
    document.addEventListener("keydown", function(event) {
      if (event.ctrlKey) {
        if (event.key === "+" || event.key === "=") {
          event.preventDefault();
          updateZoom(0.1);
        } else if (event.key === "-") {
          event.preventDefault();
          updateZoom(-0.1);
        } else if (event.key === "0") {
          event.preventDefault();
          setZoom(1);
        }
      }
    });

    // Initialize the application
    function initApp() {
      // Add first blank page if no file is loaded
      if (viewerContainer.querySelector('.loading')) {
        // Keep the loading message until user action
      }
    }

    // Run initialization
    initApp();


    async function exportPdfWithAnnotations() {
      if (renderedPages.length === 0) {
        alert("No content to export!");
        return;
      }

      const exportButton = document.getElementById("exportPdfButton");
      const originalButtonText = exportButton.textContent;
      exportButton.textContent = "Exporting...";
      exportButton.disabled = true;
      // Optional: Show a more prominent loading indicator on the page
      const loadingIndicator = document.createElement('div');
      loadingIndicator.className = 'loading';
      loadingIndicator.textContent = 'Exporting PDF, please wait...';
      loadingIndicator.style.position = 'fixed';
      loadingIndicator.style.top = '50%';
      loadingIndicator.style.left = '50%';
      loadingIndicator.style.transform = 'translate(-50%, -50%)';
      loadingIndicator.style.zIndex = '2000'; // Ensure it's on top
      loadingIndicator.style.padding = '20px';
      loadingIndicator.style.background = 'rgba(0,0,0,0.7)';
      loadingIndicator.style.borderRadius = '8px';
      document.body.appendChild(loadingIndicator);


      const { jsPDF } = window.jspdf;
      let pdfExportDoc; // Will be initialized with the first page's dimensions

      try {
        for (let i = 0; i < renderedPages.length; i++) {
          const pageData = renderedPages[i];
          const container = pageData.container;

          const baseCanvas = container.querySelector(".base-layer"); // Catches both .pdf-page and .blank-page
          const annotationCanvas = container.querySelector(".annotation-layer");

          if (!baseCanvas || !annotationCanvas) {
            console.warn(`Skipping page ${i + 1} due to missing canvas layers.`);
            continue;
          }

          // Create a new canvas to merge the base and annotation layers
          const mergedCanvas = document.createElement('canvas');
          const mergedCtx = mergedCanvas.getContext('2d');

          // Set merged canvas dimensions to the original, unzoomed dimensions
          mergedCanvas.width = baseCanvas.width; // Original width
          mergedCanvas.height = baseCanvas.height; // Original height

          // 1. Draw the base layer (PDF page content or white background)
          mergedCtx.drawImage(baseCanvas, 0, 0, baseCanvas.width, baseCanvas.height);

          // 2. Draw the annotation layer on top
          mergedCtx.drawImage(annotationCanvas, 0, 0, annotationCanvas.width, annotationCanvas.height);

          // Convert the merged canvas to an image data URL
          const imgData = mergedCanvas.toDataURL('image/png'); // Use PNG for better quality of drawings

          if (i === 0) {
            // Initialize jsPDF with the dimensions of the first page
            // Determine orientation based on aspect ratio
            const orientation = mergedCanvas.width > mergedCanvas.height ? 'l' : 'p'; // 'l' for landscape, 'p' for portrait
            pdfExportDoc = new jsPDF({
              orientation: orientation,
              unit: 'px', // Using pixels since canvas dimensions are in pixels
              format: [mergedCanvas.width, mergedCanvas.height] // Custom format based on canvas size
            });
          } else {
            // Add a new page with the same dimensions and orientation as the current canvas
            const orientation = mergedCanvas.width > mergedCanvas.height ? 'l' : 'p';
            pdfExportDoc.addPage([mergedCanvas.width, mergedCanvas.height], orientation);
          }

          // Add the image to the PDF page
          // Parameters: imageData, format, x, y, width, height
          pdfExportDoc.addImage(imgData, 'PNG', 0, 0, mergedCanvas.width, mergedCanvas.height);

          // Browser time to chill
          await new Promise(resolve => setTimeout(resolve, 30));
        }

        if (pdfExportDoc) {
          pdfExportDoc.save('annotated_document.pdf'); // Trigger download
        } else {
          alert("No pages were processed for export.");
        }

      } catch (error) {
        console.error("Error during PDF export:", error);
        alert("An error occurred while exporting the PDF: " + error.message);
      } finally {
        // Restore button and remove loading indicator
        exportButton.textContent = originalButtonText;
        exportButton.disabled = false;
        if (loadingIndicator && loadingIndicator.parentNode) {
          loadingIndicator.parentNode.removeChild(loadingIndicator);
        }
      }
    }



  
  </script>
  
  <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
  <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

  
  <!-- BEGINNING OF AI -->

  
  <div class="pane" id="chatPane">
    <div class="title">
      <h2>Mr. GPT</h2>
    </div>

    <div class="content">
      <div id="chatbox" class="message-container">
        <!-- Chat messages will appear here -->
      </div>

      <div class="input-area">

        <input type="text" id="userInput" placeholder="Ask me anything...">
        <button onclick="sendMessage()">Send</button>
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        <button onclick="openFileExplorer();" >Upload</button>
        <button id="screenshotButton">Screenshot</button>
      </div>
    </div>

    <div class="corner"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script src="panes.js"></script>
  <script src="script.js"></script>
  
</body>

<!-- AI CHATBOT -->
<script>
  const apiKEY = "AIzaSyCPKC1F6MNR7YvhDZGEhmUFPcaBSFRw-PU"; // Api key should be safe <33
  const chatbox = document.getElementById('chatbox');
  let booleaner = false;
  let chatHistory = [];
  let isCachingEnabled = true;

  function toggleCaching() {
    isCachingEnabled = document.getElementById("cacheToggle").checked;
  }

  function openFileExplorer() {
    document.getElementById('fileInput').click();
  }

  async function sendMessage() {
    function renderMathInElementSafe(el) {
      if (typeof renderMathInElement === 'function') {
        renderMathInElement(el, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false }
          ],
          throwOnError: false
        });
      }
    }

    booleaner = true;
    const input = document.getElementById("userInput");
    const message = input.value;
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];

    // Don't send empty messages!
    if (!message && !file) {
      return;
    }

    // Add user message to chat
    const userDiv = document.createElement("div");
    userDiv.className = "user";
    userDiv.innerHTML = `<strong>You:</strong> ${message}`;
    chatbox.appendChild(userDiv);

    // Clear input field
    input.value = "";

    let imagePart = null;
    if (file) {
      const base64String = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result.split(',')[1]);
        };
        reader.readAsDataURL(file);
      });

      const imgElement = document.createElement("img");
      imgElement.src = URL.createObjectURL(file);
      imgElement.style.maxWidth = "200px";
      userDiv.appendChild(imgElement);

      imagePart = {
        inlineData: {
          mimeType: file.type,
          data: base64String
        }
      };
    }

    // Create API request parts
    const parts = [{ text: message }];
    if (imagePart) parts.push(imagePart);
    const userContent = { role: "user", parts };

    // Add to chat history if caching is enabled (enabled by default)
    if (isCachingEnabled) {
      chatHistory.push(userContent);
    }

    try {
      // Send request to API
      const response = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=" + apiKEY,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: chatHistory
          })
        }
      );

      const data = await response.json();
      const rawBotMessage = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response";

      // Add to chat history if caching is enabled
      if (isCachingEnabled) {
        chatHistory.push({ role: "model", parts: [{ text: rawBotMessage }] });
      }

      // Parse and display bot message
      const botHtml = marked.parse(rawBotMessage);
      const botDiv = document.createElement("div");
      botDiv.className = "bot";
      botDiv.innerHTML = `<strong>Mr. GPT:</strong> ${botHtml}`;
      chatbox.appendChild(botDiv);

      // Render math expressions (LaTeX (Lay-Tek))
      renderMathInElementSafe(botDiv);

    } catch (error) {
      console.error("Error:", error);
      const errorDiv = document.createElement("div");
      errorDiv.className = "bot";
      errorDiv.innerHTML = "<strong>Mr. GPT:</strong> Sorry, there was an error processing your request.";
      chatbox.appendChild(errorDiv);
    }

    // Scroll to bottom
    chatbox.scrollTop = chatbox.scrollHeight;
    fileInput.value = "";
  }

  const screenshotButton = document.getElementById('screenshotButton');
  const pdfViewerContainer = document.getElementById('pdf-viewer-container');
  let isSelecting = false;
  let startX, startY, endX, endY;
  let selectionOverlay;
  let activeCanvasContainer = null; // To track which page is being selected

  function createSelectionOverlay() {
      selectionOverlay = document.createElement('div');
      selectionOverlay.id = 'selectionOverlay';
      pdfViewerContainer.appendChild(selectionOverlay);
  }

  function startSelection(e) {
        stopDrawing();
        isSelecting = true;
        const targetCanvasContainer = e.target.closest('.canvas-container');
        if (targetCanvasContainer) {
            activeCanvasContainer = targetCanvasContainer;
            const containerRect = activeCanvasContainer.getBoundingClientRect();
            const pdfViewerRect = pdfViewerContainer.getBoundingClientRect();

            // Calculate start coordinates relative to the page container AND the PDF viewer's scroll
            startX = e.clientX - containerRect.left;
            startY = e.clientY - containerRect.top;

            // Position the selection overlay relative to the PDF viewer container
            if (!selectionOverlay) {
                createSelectionOverlay();
                pdfViewerContainer.style.position = 'relative'; // Ensure the container is positioned
            }

            selectionOverlay.style.position = 'absolute'; // Make sure overlay is positioned absolutely within the container
            selectionOverlay.style.left = `${containerRect.left - pdfViewerRect.left + startX}px`;
            selectionOverlay.style.top = `${containerRect.top - pdfViewerRect.top + startY}px`;
            selectionOverlay.style.width = '0px';
            selectionOverlay.style.height = '0px';
            selectionOverlay.style.display = 'block';
        }
  }

  function updateSelection(e) {
    if (!isSelecting || !activeCanvasContainer) return;

    const containerRect = activeCanvasContainer.getBoundingClientRect();
    const pdfViewerRect = pdfViewerContainer.getBoundingClientRect();

    const currentX = e.clientX - containerRect.left;
    const currentY = e.clientY - containerRect.top;

    const width = Math.abs(currentX - startX);
    const height = Math.abs(currentY - startY);
    const left = Math.min(startX, currentX);
    const top = Math.min(startY, currentY);

    // Update the overlay's position based on the initial offset from the PDF viewer
    selectionOverlay.style.left = `${containerRect.left - pdfViewerRect.left + left}px`;
    selectionOverlay.style.top = `${containerRect.top - pdfViewerRect.top + top}px`;
    selectionOverlay.style.width = `${width}px`;
    selectionOverlay.style.height = `${height}px`;
  }

  function finishSelection() {
      if (!isSelecting) return;
      isSelecting = false;

      if (selectionOverlay && parseInt(selectionOverlay.style.width) > 0 && parseInt(selectionOverlay.style.height) > 0 && activeCanvasContainer) {
          captureSelectedPDFArea();
      }

      if (selectionOverlay) {
          selectionOverlay.style.display = 'none';
      }
      activeCanvasContainer = null; // Reset active container
  }

  async function captureSelectedPDFArea() {

      if (!activeCanvasContainer) return;

      const rect = selectionOverlay.getBoundingClientRect();
      const containerRect = activeCanvasContainer.getBoundingClientRect();

      const scaleX = window.devicePixelRatio;
      const scaleY = window.devicePixelRatio;

      const canvas = document.createElement('canvas');
      canvas.width = Math.floor(rect.width * scaleX);
      canvas.height = Math.floor(rect.height * scaleY);
      const ctx = canvas.getContext('2d');

      ctx.scale(scaleX, scaleY);

      const baseCanvas = activeCanvasContainer.querySelector('.base-layer');
      const annotationCanvas = activeCanvasContainer.querySelector('.annotation-layer');

      if (baseCanvas) {
          // 1. Draw the base PDF content
          ctx.drawImage(
              baseCanvas,
              (rect.left - containerRect.left + pdfViewerContainer.scrollLeft) * (baseCanvas.width / containerRect.width),
              (rect.top - containerRect.top + pdfViewerContainer.scrollTop) * (baseCanvas.height / containerRect.height),
              rect.width * (baseCanvas.width / containerRect.width),
              rect.height * (baseCanvas.height / containerRect.height),
              0,
              0,
              rect.width,
              rect.height
          );

          // 2. If there's an annotation layer, draw its content on top
          if (annotationCanvas) {
              ctx.drawImage(
                  annotationCanvas,
                  (rect.left - containerRect.left + pdfViewerContainer.scrollLeft) * (annotationCanvas.width / containerRect.width),
                  (rect.top - containerRect.top + pdfViewerContainer.scrollTop) * (annotationCanvas.height / containerRect.height),
                  rect.width * (annotationCanvas.width / containerRect.width),
                  rect.height * (annotationCanvas.height / containerRect.height),
                  0,
                  0,
                  rect.width,
                  rect.height
              );
          }

          const base64Image = canvas.toDataURL('image/png').split(',')[1];
          await sendScreenshotToAI(base64Image);
      } else {
          console.error("Base PDF canvas not found in the selected container.");
      }
  }

  async function sendScreenshotToAI(base64Image) {
      const imagePart = {
          inlineData: {
              mimeType: 'image/png',
              data: base64Image
          }
      };

      const parts = [{ text: "Analyze this part of the PDF." }, imagePart];
      const userContent = { role: "user", parts };

      if (isCachingEnabled) {
          chatHistory.push(userContent);
      }

      try {
          const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${apiKEY}`,
              {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                      contents: chatHistory
                  })
              }
          );

          const data = await response.json();
          const rawBotMessage = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response";

          if (isCachingEnabled) {
              chatHistory.push({ role: "model", parts: [{ text: rawBotMessage }] });
          }

          const botHtml = marked.parse(rawBotMessage);
          const botDiv = document.createElement("div");
          botDiv.className = "bot";
          botDiv.innerHTML = `<strong>Mr. GPT:</strong> ${botHtml}`;
          document.getElementById('chatbox').appendChild(botDiv); // Make sure you have a chatbox
          renderMathInElementSafe(botDiv); // Ensure this function is available or remove if not needed

      } catch (error) {
          console.error("Error:", error);
          const errorDiv = document.createElement("div");
          errorDiv.className = "bot";
          //Throwing error when not supposed to ??!?
          //errorDiv.innerHTML = "<strong>Mr. GPT:</strong> Sorry, there was an error processing the PDF screenshot.";
          //document.getElementById('chatbox').appendChild(errorDiv); // Ensure you have a chatbox
      } finally {
          document.getElementById('chatbox').scrollTop = document.getElementById('chatbox').scrollHeight; // Ensure you have a chatbox
      }
  }

  screenshotButton.addEventListener('click', () => {
      // Start selection when the button is clicked
      pdfViewerContainer.addEventListener('mousedown', startSelection);
      pdfViewerContainer.addEventListener('mousedown', stopDrawing);
      pdfViewerContainer.addEventListener('mousemove', updateSelection);
      pdfViewerContainer.addEventListener('mouseup', finishSelection);
      pdfViewerContainer.addEventListener('mouseleave', finishSelection);
  });
</script>

</html>